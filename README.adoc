My: The Language That Grows With You ğŸŒ±

My is a modern, systems-capable programming language designed for progressive complexity.
Start with the clarity of Python or Go, and grow into the expressive power of Rust or Zigâ€”without the steep learning curve.
Whether you're building CLI tools, web backends, or embedded systems, My lets you scale your mental model as your project scales.


âœ¨ Why My?




Feature

ğŸ§  My


ğŸ Python


ğŸ¦€ Rust





Memory Safety

âœ… GC + Affine Types

âœ… GC (no compile-time checks)

âœ… Ownership (complex)


Concurrency

âœ… M:N Threads + Async/Await

âŒ GIL-limited

âœ… Fearless (steep curve)


Performance

âœ… Native + WASM

âŒ Interpreted

âœ… Zero-cost abstractions


Contracts

âœ… First-Class

âŒ Runtime Assertions

âŒ Debug assertions only


Metaprogramming

âœ… Comptime

âŒ Decorators/Macros

âœ… Procedural macros


Learning Curve

âœ… Progressive

âœ… Low (but no safety)

âŒ Steep


Reversibility

âœ… Checkpoint/Rollback

âŒ Not supported

âŒ Not supported


Cut Operator

âœ… Prolog-style commitment

âŒ Not supported

âŒ Not supported



My is designed to be auditable, composable, and future-proofâ€”ideal for systems programming, tooling, and governance platforms.


ğŸ§­ Modes of Collaboration

My supports three distinct modes of development, each tailored to your preferred balance of human and AI collaboration:



Mode
Description
Ideal For
Status





ğŸ§ Solo

Human-first: You write, My assists
Craftsmanship, pedagogy, control

âœ… Implemented




ğŸ¤ Duo

Balanced: You and My co-create
Pair programming, prototyping

ğŸš§ In Development



ğŸ§  Ensemble

AI-first: My leads, you refine
Exploration, automation, orchestration

ğŸ“‹ Planned



Each mode is opt-in and narratableâ€”your repo can declare its mode, and My adapts its tooling, suggestions, and audit trails accordingly.

ğŸ§ Solo Mode Features (Implemented)

The Solo dialect is now fully operational with these cutting-edge features:


Affine Types - Resources that must be used exactly once (no accidental duplication)

Linear Types - Resources that must be consumed (no resource leaks)

Cut Operator (!) - Prolog-style parsing commitment (no backtracking after cut)

Partial Reversibility - Checkpoint and rollback for computation recovery

Pattern Matching - Algebraic data types with exhaustive matching

Async/Await - First-class asynchronous programming

Contracts - Design-by-contract with requires and ensures


Move Semantics - Explicit resource management



ğŸŒˆ Newtonian Spectrum of Agents

In Ensemble mode, My orchestrates a team of agentic octopusesâ€”each colored according to Newton's sevenfold rainbow.
This metaphor reflects decomposed capability, not cultural signaling, and evokes clarity through spectral analysis.



Color
Role Symbolism
Solo Implementation





ğŸ”´ Red

Performance agent (hot path, core)
Optimized recursive descent parser



ğŸŸ  Orange

Concurrency agent (thread orchestration)
Async/await foundations



ğŸŸ¡ Yellow

Contract agent (validation, safety)
Affine/linear type tracking



ğŸŸ¢ Green

Config agent (schema, hygiene)
Structured AST



ğŸ”µ Blue

Audit agent (trace, log, narrate)
Checkpoint/rollback system



ğŸŸ£ Indigo

Comptime agent (metaprogramming)
Compile-time evaluation (planned)



ğŸŸ¤ Violet

Governance agent (policy, mode)
Mode declaration system




ğŸ» The conductor octopus orchestrates this ensembleâ€”each agent playing its part in harmony, from ledger scrolls to circuit boards.



ğŸ“¦ Installation

Prerequisites


# Ubuntu/Debian
sudo apt-get install ocaml

# Fedora/RHEL
sudo dnf install ocaml

# macOS
brew install ocaml

# Arch Linux
sudo pacman -S ocaml


Building from Source


git clone https://gitlab.com/your-org/my-lang  # Use your GitLab URL
cd my-lang
./scripts/build.sh  # Builds all dialects


Quick Start (Solo Mode)


cd solo-dialect
./build.sh
./solo  # Run the compiler




ğŸš€ Language Examples

Hello World (Solo)


fn main() {
    let msg = "Hello, My!";
    println(msg);
    return 0;
}


Affine Types - Resource Management


fn transfer(affine token: Token) -> Result {
    checkpoint save_state {
        let result = process(move token);  // Must move, can't copy
        if !result.is_ok() {
            rollback save_state;  // Partial reversibility
        }
        return result;
    }
}


Cut Operator - Parser Commitment


fn parse_expression(input: String) -> Expr {
    match input {
        "(" => {
            let expr = parse_nested();
            !  // Cut - no backtracking after this
            expect(")");
            return expr;
        },
        _ => parse_simple()
    }
}


Linear Types - Guaranteed Consumption


fn process_data(linear data: SecureData) {
    let encrypted = encrypt(move data);  // data consumed
    send_to_server(move encrypted);      // encrypted consumed
    // Compile error if data not consumed!
}


Reversible Computation


fn distributed_compute() {
    reverse {
        let step1 = expensive_operation();
        let step2 = transform(step1);
        if !valid(step2) {
            // Automatically reverses to start
        }
        return step2;
    }
}




ğŸ—ï¸ Architecture


my-lang/
â”œâ”€â”€ README.md                    # This file
â”œâ”€â”€ LICENSE                      # Your license
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ build.sh                # Master build script
â”œâ”€â”€ solo-dialect/               # Human-first mode âœ…
â”‚   â”œâ”€â”€ solo_compiler.ml        # Complete OCaml implementation
â”‚   â”œâ”€â”€ README.md               # Solo-specific docs
â”‚   â”œâ”€â”€ build.sh               # Solo build script
â”‚   â””â”€â”€ examples/
â”œâ”€â”€ duet-dialect/              # AI-balanced mode ğŸš§
â”‚   â””â”€â”€ README.md              # Design specification
â””â”€â”€ ensemble-dialect/          # AI-first mode ğŸ“‹
    â””â”€â”€ README.md              # Vision document




ğŸ§ª Testing


# Run Solo compiler tests
cd solo-dialect
./solo  # Runs built-in test suite

# Test your own My program
echo 'fn main() { return 42; }' > test.my
./solo test.my




ğŸ“š Documentation



Solo Dialect Guide - Complete guide to the implemented features

Language Specification - Formal language specification (coming soon)

Affine Types Tutorial - Learn resource management (coming soon)

Reversibility Patterns - Checkpoint/rollback patterns (coming soon)



ğŸ¤ Contributing

We welcome contributions that align with My's philosophy of progressive complexity and human-AI collaboration.

Fork the repository
Create a feature branch (git checkout -b feature/amazing-feature)
Commit your changes (git commit -m 'Add amazing feature')
Push to the branch (git push origin feature/amazing-feature)
Open a Pull Request

Development Principles



Simplicity First - Start simple, grow complex only when needed

Safety by Default - Affine/linear types prevent resource bugs

Reversibility - Support undo/redo at the language level

Progressive Disclosure - Advanced features are opt-in

Narratable Code - Code should tell a story



ğŸ“ˆ Roadmap


âœ… Phase 1: Solo Mode (Complete)



 Lexer and Parser with Cut Operator

 Affine and Linear Type System

 Checkpoint/Rollback Mechanism

 Pattern Matching

 Async/Await Foundations


ğŸš§ Phase 2: Duo Mode (Q1 2025)



 LSP Server Implementation

 AI Pair Programming Interface

 Suggestion Engine

 Collaborative Debugging


ğŸ“‹ Phase 3: Ensemble Mode (Q2 2025)



 Multi-Agent Orchestration

 Newtonian Spectrum Implementation

 Policy Engine

 Distributed Compilation



ğŸ”’ Security

My takes security seriously with:

Memory safety through affine/linear types
No undefined behavior by design
Capability-based security model
Auditable compilation process

Report security vulnerabilities to: security@my-lang.org


ğŸ“„ License

This project is licensed under the MIT License - see the LICENSE file for details.


ğŸ™ Acknowledgments


The Rust community for proving memory safety matters
The OCaml community for the implementation language
Prolog for inspiring the cut operator
The reversible computing research community



ğŸ’¬ Community



Discord: discord.gg/my-lang


Forum: forum.my-lang.org


Twitter: @MyLangOfficial



"A language that grows with you, from solo craftsmanship to ensemble orchestration." ğŸŒ±ğŸ»
